/*     */ package me.nzxter.bettercraft.mods.shader;
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BackgroundShader2
/*     */ {
/*   7 */   public static String EaZy1 = "#ifdef GL_ES\nprecision highp float; // ios\n#endif\n\n\nuniform float time;\nuniform vec2 resolution;\n\n\n#define iterations 4\n#define formuparam2 .9\n\n#define volsteps 5\n#define stepsize 0.190\n\n#define zoom 2.9\n#define tile   0.45\n#define speed2  0.0\n\n#define brightness 0.1\n#define darkmatter 0.4\n#define distfading 0.56\n#define saturation 0.9\n\n\n#define transverseSpeed 0.0\n#define cloud 0.2\n\n\nfloat triangle(float x, float a)\n{\nfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\nreturn output2;\n}\n\n\nfloat field(in vec3 p) {\n\tfloat strength = 8. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.2 + 2.0), -1.1+0.3*cos(time*0.15));\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n\n\nvoid main()\n{\n     \tvec2 uv2 = 2. * gl_FragCoord.xy / resolution.xy - 1.;\n\tvec2 uvs = uv2 * resolution.xy / max(resolution.x, resolution.y);\n\n\n\tfloat time2 = time*0.7;\n\n        float speed = speed2;\n        //speed = 0.005 * cos(time2*0.002 + 3.1415926/4.0);\n\n\tspeed = 0.1;\n\n\n    \tfloat formuparam = formuparam2;\n\n\n\n\t//get coords and direction\n\n\tvec2 uv = uvs;\n\n\n\n\t//mouse rotation\n\tfloat a_xz = 0.9;\n\tfloat a_yz = -.6;\n\tfloat a_xy = 0.9 + time*0.04;\n\n\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\n\n\tfloat v2 =1.0;\n\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\tvec3 from=vec3(0.0, 0.0,0.0);\n\n\n\tvec3 forward = vec3(0.,0.,1.);\n\n\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;\n\t\tfrom.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;\n\n\tfrom.z += 0.003*time;\n\n\n\tdir.xy*=rot_xy;\n\tforward.xy *= rot_xy;\n\n\tdir.xz*=rot_xz;\n\tforward.xz *= rot_xz;\n\n\n\tdir.yz*= rot_yz;\n\tforward.yz *= rot_yz;\n\n\n\n\tfrom.xy*=-rot_xy;\n\tfrom.xz*=rot_xz;\n\tfrom.yz*= rot_yz;\n\n\n\t//zoom\n\tfloat zooom = (time2-3311.)*speed;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize; // make from 0 to 1\n\n\n\n\t//volumetric rendering\n\tfloat s=0.24;\n\tfloat s3 = s + stepsize/2.0;\n\tvec3 v=vec3(0.);\n\tfloat t3 = 0.0;\n\n\n\tvec3 backCol2 = vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\tvec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*3.5))); // tiling fold\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n\n\t\t#ifdef cloud\n\t\tt3 = field(p3);\n\t\t#endif\n\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\n\t\t\t//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n\t\t\tfloat D = abs(length(p2)-pa); // absolute sum of average change\n\n\t\t\tif (i > 2)\n\t\t\t{\n\t\t\ta += i > 7 ? min( 12., D) : D;\n\t\t\t}\n\t\t\t\tpa=length(p2);\n\t\t}\n\n\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t// brightens stuff up a bit\n\t\tfloat s1 = s+zoffset;\n\t\t// need closed form expression for this, now that we shift samples\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\n\n\t\t//t3 += fade;\n\n\t\tv+=fade;\n\t       \t\t//backCol2 -= fade;\n\n\t\t// fade out samples as they approach the camera\n\t\tif( r == 0 )\n\t\t\tfade *= (1. - (sampleShift));\n\t\t// fade in samples as they approach from the distance\n\t\tif( r == volsteps-1 )\n\t\t\tfade *= sampleShift;\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n\n\n\t\ts+=stepsize;\n\t\ts3 += stepsize;\n\n\n\n\t\t}\n\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\n\n\n\n\tvec4 forCol2 = vec4(v*.01,1.);\n\n\t#ifdef cloud\n\tbackCol2 *= cloud;\n\t#endif\n\n\tbackCol2.b *= 0.01;\n\n\tbackCol2.r *= 0.01;\n\n\n\n\tbackCol2.b = 0.5*mix(backCol2.b, backCol2.g, 1.2);\n\tbackCol2.g = 0.01;\n\n\tbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));\n\n\tgl_FragColor = forCol2 + vec4(backCol2, 1.0);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public static String EaZy2 = "\t#ifdef GL_ES\n\tprecision mediump float;\n\t#endif\n\n\tuniform float time;\n\tuniform vec2 mouse;\n\tuniform vec2 resolution;\n\n\t// a raymarching experiment by kabuto\n\n\t#define R_FACTOR 5.\n\t#define G_FACTOR 0.\n\t#define B_FACTOR 0.\n\n\tconst int MAXITER = 42;\n\n\tvec3 field(vec3 p) {\n\t\tp *= .1;\n\t\tfloat f = .1;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tp = p.yzx*mat3(.8,.6,0,-.6,.8,0,0,0,1);\n\t\t\tp += vec3(.123,.456,.789)*float(i);\n\t\t\tp = abs(fract(p)-.5);\n\t\t\tp *= 2.0;\n\t\t\tf *= 2.0;\n\t\t}\n\t\tp *= p;\n\t\treturn sqrt(p+p.yzx)/f-.002;\n\t}\n\n\tvoid main( void ) {\n\t\tvec3 dir = normalize(vec3((gl_FragCoord.xy-resolution*.5)/resolution.x,1.));\n\t\tvec3 pos = vec3(.4, .5,time);\n\t\tvec3 color = vec3(0);\n\t\tfor (int i = 0; i < MAXITER; i++) {\n\t\t\tvec3 f2 = field(pos);\n\t\t\tfloat f = min(min(f2.x,f2.y),f2.z);\n\t\t\t\n\t\t\tpos += dir*f;\n\t\t\tcolor += float(MAXITER-i)/(f2+.001);\n\t\t}\n\t\tvec3 color3 = vec3(1.-1./(1.+color*(.09/float(MAXITER*MAXITER))));\n\t\tcolor3 *= color3;\n\t\tgl_FragColor = vec4(color3.r*R_FACTOR, color3.g*G_FACTOR, color3.b*B_FACTOR,1.);\n\t}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  92 */   public static String staticGod = "#ifdef GL_ES \r\n            precision mediump float; \r\n#endif \r\n\r\n#extension GL_OES_standard_derivatives : enable \r\n             \r\n// DOF Snowfield! \r\n// Mouse X controls focal depth \r\n             \r\nuniform float time; \r\nuniform vec2 mouse; \r\nuniform vec2 resolution; \r\n\r\nvec3 snowflake(vec3 coords, vec2 pxPos) { \r\n\tfloat focalPlane = 0.5 + 2.5 * 0.7; \r\n\tfloat iris = 0.01;\r\n\t\r\n\tfloat pxDiam = abs(coords.z - focalPlane) * iris; \r\n\tvec2 flakePos = vec2(coords.xy) / coords.z; \r\n\tfloat flakeDiam = 0.003 / coords.z; \r\n\t\r\n\tfloat dist = length(pxPos - flakePos); \r\n\tfloat bri = (pxDiam + flakeDiam - dist) / (pxDiam * 2.0); \r\n\tif (pxDiam > flakeDiam) { \r\n\t\tbri /= (pxDiam / flakeDiam); \r\n\t} \r\n\r\n\treturn vec3(0.7, 0.9, 1.0) * min(1.0, max(0.0, bri)); \r\n}\r\n\r\nvoid main( void ) { \r\n    vec2 pos = ( gl_FragCoord.xy / resolution.xy ) - 0.5; \r\n    pos.y *= resolution.y / resolution.x; \r\n     \r\n    gl_FragColor.rgb = vec3(0.04, 0.13, 0.19); \r\n    for (int i=0; i<150; i++) { \r\n\t    vec3 c = vec3(0); \r\n\t    c.z = fract(sin(float(i) * 25.643) * 735.5373); \r\n\t    c.z *= 0.2 + fract(sin(float(i) * 74.753) * 526.5463); \r\n\t    c.z = 0.5 + (1.0 - c.z) * 2.4; \r\n\t    float gSize = 0.5 / c.z; \r\n\t    vec2 drift = vec2(0); \r\n\t    drift.x = fract(sin(float(i) * 52.3464) * 353.43354) * 4.0; \r\n\t    drift.x = drift.x + time * 0.06 + 4.0 * sin(time * 0.03 + c.z * 7.0); \r\n\t    drift.y = fract(sin(float(i) * 63.2356) * 644.53463) * 4.0; \r\n\t    drift.y = drift.y + time * -0.2; \r\n\t    drift /= c.z; \r\n\t     \r\n\t    vec2 grid = vec2(mod((pos.x+drift.x)/c.z, gSize), mod((pos.y-drift.y)/c.z, gSize)); \r\n\t    c.x = gSize*0.5; \r\n\t    c.y = gSize*0.5; \r\n\t    gl_FragColor.rgb += snowflake(c, grid); \r\n    } \r\n    gl_FragColor.a = 1.0; \r\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 119 */   public static String Julian = "/*\n * Original shader from: https://www.shadertoy.com/view/4lXfDf\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// 1D noise\nfloat noise1(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\t\t\t\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < res.x)\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t}\n\t\t\telse if(d < res.y)\n\t\t\t{\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float flicker = noise1(iTime * 2.0) * 0.8 + 0.4;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n\tvec2 suv = uv;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float amp1 = 1.0 - voronoi(uv + vec2(iTime*0.1, 0.0));\n    float amp2 = 1.0 - voronoi(uv * 2.5 + vec2(4.5 + - iTime*0.05, 5.5 - iTime*0.1));\n    \n\n    \n    \n    amp1 = 2.0*smoothstep(0.945, 0.99, amp1) * smoothstep(0.99, 0.945, amp1) + 3.0*smoothstep(0.84, 0.86, amp1)*smoothstep(0.86, 0.840, amp1) +\n        + 2.0*smoothstep(0.74, 0.76, amp1)*smoothstep(0.76, 0.740, amp1);\n    amp2 = 0.25*smoothstep(0.95, 1.0, amp2) + 1.5*smoothstep(0.74, 0.76, amp2)*smoothstep(0.76, 0.740, amp2);\n\tamp2 *= 2.0;\n    amp2 += 0.5;\n    \n  \n    // uncomment for weird mode\n    \n    /*\n    uv.x += 0.1*sin(iTime*0.34) * cos(iTime*0.11313);\n\n    uv.y += 0.8 * abs(uv.x) * max(suv.y, 0.0);\n   \tuv.y = uv.y * uv.y * 1.2;\n    */\n    \n    // weird mode option 2\n    //uv.xy *= uv.xy;\n\n    \n\n        \n        \n    \n    // vignetting\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    float vign = (1.1-.5*dot(sc.xy,sc.xy));\n    float midShad = length(uv) * 0.5;\n    midShad *= midShad;\n    vec4 col = vec4(0.0, 0.6, 0.9, 1.0);\n    //col = vec4(1.0, 0.2, 0.2, 1.0);\n    fragColor = col * (18.0*amp1*amp1 * amp2 * midShad) * vign * vign;\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public static String Sandbox = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// a raymarching experiment by kabuto\n\n\nconst int MAXITER = 42;\n\nvec3 field(vec3 p) {\n\tp *= .1;\n\tfloat f = .1;\n\tfor (int i = 0; i < 5; i++) {\n\t\tp = p.yzx*mat3(.8,.6,0,-.6,.8,0,0,0,1);\n\t\tp += vec3(.123,.456,.789)*float(i);\n\t\tp = abs(fract(p)-.5);\n\t\tp *= 2.0;\n\t\tf *= 2.0;\n\t}\n\tp *= p;\n\treturn sqrt(p+p.yzx)/f-.002;\n}\n\nvoid main( void ) {\n\tvec3 dir = normalize(vec3((gl_FragCoord.xy-resolution*.5)/resolution.x,1.));\n\tvec3 pos = vec3(mouse-.5,time);\n\tvec3 color = vec3(0);\n\tfor (int i = 0; i < MAXITER; i++) {\n\t\tvec3 f2 = field(pos);\n\t\tfloat f = min(min(f2.x,f2.y),f2.z);\n\t\t\n\t\tpos += dir*f;\n\t\tcolor += float(MAXITER-i)/(f2+.001);\n\t}\n\tvec3 color3 = vec3(1.-1./(1.+color*(.09/float(MAXITER*MAXITER))));\n\tcolor3 *= color3;\n\tgl_FragColor = vec4(color3,1.);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 175 */   public static String Flames = "/*\n * Original shader from: https://www.shadertoy.com/view/wl2Gzc\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// Emulate some GLSL ES 3.x\n#define mat2x2 mat2\n\n// --------[ Original ShaderToy begins here ]---------- //\n\nfloat hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    //vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n#define PI 3.1415927\n#define TWO_PI 6.283185\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.7, -1.0)\n\n#define PARTICLE_SIZE 0.009\n\n#define PARTICLE_SCALE (vec2(0.5, 1.6))\n#define PARTICLE_SCALE_VAR (vec2(0.25, 0.2))\n\n#define PARTICLE_BLOOM_SCALE (vec2(0.5, 0.8))\n#define PARTICLE_BLOOM_SCALE_VAR (vec2(0.3, 0.1))\n\n#define SPARK_COLOR vec3(1.0, 0.4, 0.05) * 1.5\n#define BLOOM_COLOR vec3(1.0, 0.4, 0.05) * 0.8\n#define SMOKE_COLOR vec3(1.0, 0.43, 0.1) * 0.8\n\n#define SIZE_MOD 1.05\n#define ALPHA_MOD 0.9\n#define LAYERS_COUNT 15\n\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n \tfloat noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset = vec2(0.);\n    for (int i = 0; i < 10; i++)\n    {\n        if (i >= layers) break;\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n        \n        //Adding noise with movement\n     \tnoise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    noise *= (1.0 - alphaMod)/(1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n//Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n//Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;   \n}\n\nvec2 randomAround2_2(in vec2 point, in vec2 range, in vec2 uv)\n{\n \treturn point + (hash2_2(uv) - 0.5) * range;\n}\n\n\nvec3 fireParticles(in vec2 uv, in vec2 originalUV)\n{\n    vec3 particles = vec3(0.0);\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    float dist = 2.0;\n    float distBloom = 0.0;\n   \n   \t//UV manipulation for the faster particle movement\n    vec2 tempUV = uv + (noise2_2(uv * 2.0) - 0.5) * 0.1;\n    tempUV += -(noise2_2(uv * 3.0 + iTime) - 0.5) * 0.07;\n\n    //Sparks sdf\n    dist = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_SCALE, PARTICLE_SCALE_VAR, rootUV));\n    \n    //Bloom sdf\n    distBloom = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_BLOOM_SCALE, PARTICLE_BLOOM_SCALE_VAR, rootUV));\n\n    //Add sparks\n    particles += (1.0 - smoothstep(PARTICLE_SIZE * 0.6, PARTICLE_SIZE * 3.0, dist)) * SPARK_COLOR;\n    \n    //Add bloom\n    particles += pow((1.0 - smoothstep(0.0, PARTICLE_SIZE * 6.0, distBloom)) * 1.0, 3.0) * BLOOM_COLOR;\n\n    //Upper disappear curve randomization\n    float border = (hash1_2(rootUV) - 0.5) * 2.0;\n \tfloat disappear = 1.0 - smoothstep(border, border + 0.5, originalUV.y);\n\t\n    //Lower appear curve randomization\n    border = (hash1_2(rootUV + 0.214) - 1.8) * 0.7;\n    float appear = smoothstep(border, border + 0.4, originalUV.y);\n    \n    return particles * disappear * appear;\n}\n\n\n//Layering particles to imitate 3D view\nvec3 layeredParticles(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float smoke) \n{ \n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 offset = vec2(0.0);\n    vec2 noiseOffset;\n    vec2 bokehUV;\n    \n    for (int i = 0; i < LAYERS_COUNT; i++)\n    {\n        //Particle noise movement\n        noiseOffset = (noise2_2(uv * size * 2.0 + 0.5) - 0.5) * 0.15;\n        \n        //UV with applied movement\n        bokehUV = (uv * size + iTime * MOVEMENT_DIRECTION * MOVEMENT_SPEED) + offset + noiseOffset; \n        \n        //Adding particles\t\t\t\t\t\t\t\tif there is more smoke, remove smaller particles\n\t\tparticles += fireParticles(bokehUV, uv) * alpha * (1.0 - smoothstep(0.0, 1.0, smoke) * (float(i) / float(layers)));\n        \n        //Moving uv origin to avoid generating the same particles\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n        \n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n    \n    uv *= 1.8;\n    \n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0); \n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n    \n    //Cutting holes in smoke\n    smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n    \n    vec3 particles = layeredParticles(uv, SIZE_MOD, ALPHA_MOD, LAYERS_COUNT, smokeIntensity);\n    \n    vec3 col = particles + smoke + SMOKE_COLOR * 0.02;\n\tcol *= vignette;\n    \n    col = smoothstep(-0.08, 1.0, col);\n\n    fragColor = vec4(col, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 273 */   public static String Mauer = "/*\n * Original shader from: https://www.shadertoy.com/view/3sBGzV\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SkyPath.glsl\n*/\n\n#define MARCH_STEPS 100\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat box(vec3 p, vec3 s) {\n\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.6)*0.7;\n  off.x += sin(p.z*0.17)*1.5;\n\n  off.y += cos(p.z*0.27)*0.5;\n  off.y += cos(p.z*0.34)*0.25;\n  return off;\n}\n\nfloat stair(vec3 p, float s1, float s2) {\n\n  p.z = (fract(p.z/s1-0.5)-0.5)*s1;\n  p.yz *= rot(PI*0.25);\n  float b = box(p, vec3(s2,s1,s1));\n\n  return b;\n}\n\nfloat map(vec3 p) {\n\n  float rep = 10.0;\n  p.y -= max(0.0,abs(p.x)-10.0)*0.3;\n  p.x = (fract(p.x/rep-0.5)-0.5)*rep;\n  \n  p += tunnel(p);\n\n  vec3 rp = p;\n  float boxrep = 10.0;\n  rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n\n  vec3 rp2 = p;\n  float boxrep2 = 1.0;\n  rp2.x=abs(rp2.x)-0.4;\n  rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n\n  float b = box(rp + vec3(0,-9,0), vec3(0.6,10.5,0.6));\n  vec3 rp3 = rp + vec3(0,1.5,0);\n  rp3.xy *= rot(PI*0.3);\n  rp3.yz *= rot(PI*0.3);\n  float b2 = box(rp3, vec3(0.7));\n  b2 = max(b2, p.y+1.5);\n  b = min(b, b2);\n\n  \n\n  float st = stair(p, 0.1, 0.4);\n  float st2 = stair(p + vec3(0,0.7,0), 0.6, 0.4);\n\n  b = max(b, -st2);\n\n  float c = box(rp2 + vec3(0,0.3,0), vec3(0.05,0.3,0.2));\n  rp2.y = abs(rp2.y + 0.43)-0.1;\n  c = min(c, box(rp2, vec3(0.03,0.03,1.0)));\n  \n  \n\n  return min(c,min(b, st));\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*723.588+uv.yx*413.877),vec2(9865.535)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat curve2(float t, float d) {\n  float g=t/d;\n  float ig = floor(g);\n  float fg = fract(g);\n  fg = smoothstep(0.0,1.0,fg);\n  fg = pow(fg,rnd(ig)*2.0+0.5);  \n  //fg = smoothstep(0,1,fg);\n  return (ig+fg)*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float rand=rnd(uv);\n  float dither = 0.8+0.1*rand;\n\n  vec3 s=vec3(0,-1,0);\n  vec3 t=vec3(0,-0.3,3);\n  vec3 tar=vec3(0,-0.7,3);\n\n//dashxdr was here got rid of the ****ing surging\n  float motion = time*2.;\n  s.z += motion;\n  t.z += motion;\n  //tar.z += time*1.5*3.0;// + pow(curve(time, 0.7),2)*5.0;\n  float offset = 15.0;\n  tar.z += (curve2(time*1.5-offset, 1.1)+offset)*3.0 + pow(curve(time, 0.9),3.0)*5.0;\n\n  s-=tunnel(s);\n  vec3 offt = tunnel(t);\n  t-=offt;\n  tar-=tunnel(tar);\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0) - offt*0.2));\n  vec3 cy=normalize(cross(cz,cx));\n\n  vec3 r = normalize(cx*uv.x + cy*uv.y + cz);\n  \n  vec3 col = vec3(0);\n  vec3 l = normalize(vec3(-0.7,-1.0,-0.5));\n\n  vec3 back = mix(vec3(0.1,0.3,1.0)*0.1, vec3(1.0,0.3,0.5)*0.5, pow(r.y*0.5+0.5,2.0));\n\n  vec3 p = s;\n  float dd=0.0;\n  float at=0.0;\n  float at2 = 0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p) * dither;\n    if(d<0.001) {\n      vec3 n=norm(p);\n      float fog = clamp(1.0-dd*0.018, 0.0, 1.0);\n      float bot = pow(clamp(-(p.y-10.0)*.1,0.0,1.0),2.0)*fog;\n\n      float aodist = 0.3;\n      float ao = clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      ao = mix(ao,1.0,0.3);\n      \n      float f = pow(1.0-dot(n,-r), 2.0);\n      col += vec3(0.3,0.4,0.7)*max(0.0, dot(n,l)) * bot * ao;\n      col += 4.0*f * back*2.0 * (-n.y*0.5+0.5) * bot*ao;\n\n      dd = mix(100.0, d, bot);\n      \n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=d*r;\n    dd+=d;\n\n    at += exp(-length(tar-p)*7.0);\n    at2 += exp(-d*0.1)*0.05;\n  }\n\n  col -= vec3(1,0.3,0.5) * at * 3.3;\n  col -= vec3(1,0.3,0.5) * at2 * 0.2;\n  col -= back*0.05 * exp(dd*0.05);\n\n\n  fragColor = vec4(col, 1);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 340 */   public static String Boxes = "/*\n * Original shader from: https://www.shadertoy.com/view/MtdyzB\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Plento\n\nconst float smod = 0.4; // speed multiplier\n\nfloat opS( float d1, float d2 ) {return max(-d1,d2);}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nvec2 rot2(vec2 k,float t){\n\treturn vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\n}\n\n\nfloat map(vec3 rp)\n{\n   \n   float p = sin(rp.z * 0.1) * 2.3;\n   rp = vec3(rot2(rp.xy, p), rp.z);\n    \n   vec3 pos = rp - vec3(-iTime*1.6, 0.0, 4.0); \n    pos.z += iTime*2.0*smod;\n   float td = 0.07;\n    \n   vec3 b = vec3(1.0 - td*2.0, 4.0, 3.0);\n   pos = mod(pos, b) - 0.5 * b; \n  \n   pos.yz *= rot(iTime*0.3);\n    \n   float res = sdBox( pos, vec3(0.5 - td));\n    \n   res = opS(sdBox(pos, vec3(0.4, 0.4, 1.1)), res);\n   res = opS(sdBox(pos, vec3(1.1, 0.4, 0.4)), res);\n   res = opS(sdBox(pos, vec3(0.4, 1.1, 0.4)), res);\n    \n   return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.2 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n   \n    vec3 ro = vec3(0.0, 0.0, 10.0); \n    vec3 rd = normalize(vec3(uv,2.0));\n    \n    ro.z += iTime * 8.0 * smod; \n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    // glow stuff\n    float minDist = 999.0; \n    vec3 glowCol = vec3(0);\n    \n    // glow size and softness.\n    float gSize = 0.14;\n    float softness = 0.55;\n    \n    float fog = 0.0; // glow fog\n    float g = 0.0;\n    \n    for (int i = 0; i < 75; i++)\n    {\n    \td = map(ro + rd * t);\n        \n        minDist = min(minDist, d); \n        \n        if(abs(d)<0.001 || t > 25.0) \n        {\n            minDist = abs(d);\n            break;    \n        }\n        \n        t += d * 0.75;\n        \n        // Acquire some edge color if the distance to the closest object is \n        // greater than the minimum distance to an object that the ray encountered.\n        // Basically, if the ray barely misses an object, add some glow color. \n        if(d >= minDist && abs(d) > 0.15)\n        {\n            fog = smoothstep(0.13, 0.12, t / 160.0);\n            \n             glowCol += vec3(1.0, 0.0, 0.0) \n                 * smoothstep(gSize,gSize - softness, minDist) * fog ;\n            \n            g++;\n        }\n        \n    }\n    \n    glowCol /= g;\n    \n    vec3 col = vec3(0);\n    \n    col += glowCol*12.0;\n    \n    col *= smoothstep(0.99, 0.05, length(uv*0.41));\n    col *= smoothstep( 0.0, 0.6, length(uv));\n   \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 385 */   public static String Nordlich = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat random(float x) {\n    return random(vec2(x, x));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 random3(vec3 st){\n    st = vec3(dot(st,vec3(127.1,311.7,240.2)),\n\t      dot(st,vec3(269.5,183.3,346.5)),\n\t      dot(st,vec3(183.6,221.9,148.0)));\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat gradient2D(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n    //y = f*f*(3.0-2.0*f);\n\n    return mix(\n        mix(dot(random2(i + vec2(0.,0.)), f - vec2(0.,0.)),\n            dot(random2(i + vec2(1.,0.)), f - vec2(1.,0.)), u.x),\n        mix(dot(random2(i + vec2(0.,1.)), f - vec2(0.,1.)),\n            dot(random2(i + vec2(1.,1.)), f - vec2(1.,1.)), u.x), u.y);\n}\n\nfloat gradient(vec3 st) {\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n\n    // Quintic\n    vec3 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    return mix(mix(\n        mix(dot(random3(i + vec3(0.,0.,0.)), f - vec3(0.,0.,0.)),\n            dot(random3(i + vec3(1.,0.,0.)), f - vec3(1.,0.,0.)), u.x),\n        mix(dot(random3(i + vec3(0.,1.,0.)), f - vec3(0.,1.,0.)),\n            dot(random3(i + vec3(1.,1.,0.)), f - vec3(1.,1.,0.)), u.x), u.y),\n\tmix(mix(dot(random3(i + vec3(0.,0.,1.)), f - vec3(0.,0.,1.)),\n            dot(random3(i + vec3(1.,0.,1.)), f - vec3(1.,0.,1.)), u.x),\n        mix(dot(random3(i + vec3(0.,1.,1.)), f - vec3(0.,1.,1.)),\n            dot(random3(i + vec3(1.,1.,1.)), f - vec3(1.,1.,1.)), u.x), u.y), u.z);\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat gradient_octaves(vec3 st) {\n    return 0.6*gradient(st)\n          +0.4*gradient(2.*st*rot1);\n          //+0.1333333*gradient(4.*st*rot2);\n          //+0.0666667*gradient(8.*st*rot3);\n}\n\nvoid main( void ) {\n    vec2 position = gl_FragCoord.xy / resolution.y;// / resolution.xy;\n\n    vec4 color = vec4(0., 0., 0., 0.);\n    float t = mod(time*0.15, 10000.);\n    float t2 = mod(time*0.00001, 10000.);\n    float wave = gradient2D(vec2(position.x*.25,t2));\n    position.y += wave;\n    float value = (.5 + gradient_octaves(vec3(position.x*8., position.x*2.+position.y/6., t))*.5);\n    \n    float ycheat = .95;\n    value = value*((pow(sin(ycheat+position.y*3.5)*.5+.5,10.))*.5 + \n\t\t   (pow(sin(ycheat+position.y*1.5)*.5+.5,8.))*.5);\n    vec3 color_dist = vec3(0.1, .9, .5);\n\n    float starvalue = 0.;\n    vec3 stars = vec3(0.);\n    vec3 starposition = vec3(position * 1000., t2);\n    starvalue = pow(.75 + gradient_octaves(starposition)*.5, 1.);\n    stars = mix(vec3(0.,0.,0.), vec3(1.,1.,1.), smoothstep(0.99, 1.0, vec3(starvalue)));\n    stars = clamp(stars, 0.0, 1.0);\n    color.rgb = color_dist * vec3(value, pow(value, 2.)*2., value) + stars;\n    color.a = value;\n\n    gl_FragColor = color;\n\n}\n";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 433 */   public static String Face = "/*\n * Original shader from: https://www.shadertoy.com/view/MdtSWr\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define pi 3.141592654\nmat2 m = mat2(0.6, 0.8, -0.6, 0.8);\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise(in vec2 v)\n{\n    vec2 p = floor(v);\n    vec2 f = fract(v);\n    \n    f = f*f*(3.0-2.0*f);\n    \n    float n = p.x + p.y*57.0;\n    \n    return mix( mix(hash(n), hash(n+1.0), f.x), mix(hash(n+57.0), hash(n+58.0), f.x), f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p*= m*2.02;\n    f += 0.2500*noise( p ); p*= m*2.02;\n    f += 0.1250*noise( p ); p*= m*2.01;\n    f += 0.0625*noise( p );\n    \n    f /= 0.9375;\n    \n    return f;\n}\n\nvec4 uplip(vec2 q)\n{\n\n    vec4 col = vec4(0.0);\n    float w = -0.15*abs(sin(q.x *4.0)) + 0.2;\n    w *=(abs(exp(abs(q.x)*1.5)));\n\t\n\tq.y += 0.4;\n    if(q.y < w && abs(q.x) < 0.8)\n    {\n        // up tooth\n        float f= w+(-0.1*(abs(sin(q.x*60.0)))*(3.5-1.5*exp(abs(q.x))));\n\n        if(q.y > f)\n        {\n            col = mix(col, vec4(1.0), 1.0);\n\n        }\n        col *= smoothstep(w, w-0.01, q.y);\n        col *= smoothstep(f, f+0.03 , q.y);   \n\n    }\n    \n    return col;\n}\n\n\nvec4 downlip(vec2 q)\n{\n    vec4 col = vec4(0.0);\n    float dlip = (1.0-abs(cos(q.x)))*exp(abs(q.x*0.9))-0.5;\n\n    q.y += 0.0;\n    if(q.y > dlip )\n    {\n        float fd = dlip+(0.1*(abs(sin(q.x*70.0))))*(1.5-2.0*abs(q.x));\n\n        if(q.y < fd)\n        {\n            col = mix(col, vec4(1.0), 1.0);\n        }\n        col *= smoothstep(dlip, dlip+0.01, q.y);\n        col *= smoothstep(fd, fd-0.02, q.y);\n    }\n    \n    return col;\n}\n\nvec4 mixcol(vec4 a, vec4 b, float f)\n{\n\tif(a.a == 0.0)\n        return b;\n    else if(b.a == 0.0)\n        return a;\n    else\n        return mix(a, b, f);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    \n    vec4 ucol = uplip(p);\n    vec4 dcol = downlip(p);\n\tdcol = mixcol(dcol, ucol, 1.0);\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec2 p1 = vec2(p.x+0.5, p.y-0.3);\n    vec2 p2 = vec2(p.x-0.5, p.y-0.3);\n    \n    float r1 = sqrt(dot(p1, p1));\n    float r2 = sqrt(dot(p2, p2));\n \n    vec4 col = vec4(0.0);\n    \n    if(r1 < 0.25 || r2 < 0.25)\n    {\n        col =vec4(0.0, 0.8, 0.2, 1.0);\n        float f = fbm(20.0*p1);\n        col = mix(col, vec4(0.0, 0.3, 0.7, 1.0), f);\n        \n        float t = max(abs(sin(iTime))*0.8, 0.7);\n        \n        float e1 = -abs(cos(atan(p1.y, p1.x*2.0) + 0.0))*t*0.3 + 0.3;\n        f = 1.0 - smoothstep(e1, e1+0.1, length(p1)*1.8);\n        col = mix(col, vec4(0.0, 0.8, 0.4, 1.0), f);        \n     \n        float e2 = -abs(cos(atan(p2.y, p2.x*2.0) + 0.0))*t*0.3 + 0.3; \n        f = 1.0 - smoothstep(e2, e2+0.1, length(p2)*1.8);\n        col = mix(col, vec4(0.0, 0.8, 0.4, 1.0), f);\n\n        \n        if(r1 < 0.3)\n        {\n            float a = atan(p1.y, p1.x);\n            a += 0.05*fbm(20.0*p1);\n            f = smoothstep(0.4, 1.0,fbm(vec2(r1*25.0, a*18.0)));\n            col = mix(col, vec4(1.0), f);\n            f = smoothstep(0.15, 0.25, r1);\n            col *= 1.0 - f;\n            \n        }\n        else if(r2 < 0.3)\n        {\n            float a = atan(p2.y, p2.x);\n            a += 0.15*fbm(12.0*p2);\n            f = smoothstep(0.4, 1.0, fbm(vec2(r2*25.0, a*18.0)));\n            col = mix(col, vec4(1.0), f);\n            f = smoothstep(0.15, 0.25, r2);\n            col *= 1.0 - f;\n        }\n        \n        col *= smoothstep(e1, e1+0.02, length(p1)*1.8);\n        // left eye highlight\n        f = 1.0-smoothstep(0.0, 0.1, length(p1 - vec2(0.1, 0.06)));\n        col += vec4(f, f, f, 1.0);\n        \n        col *= smoothstep(e2, e2+0.02, length(p2)*1.8);\n        // right eye highlight\n        f = 1.0-smoothstep(0.0, 0.1, length(p2 - vec2(0.1, 0.06)));\n        col += vec4(f, f, f, 1.0);\n    }\n    \n    col = mixcol(col, dcol, 1.0);\n    \n    float anim = max(sin(iTime*0.3), 0.0);\n    col = mix(col, vec4(0.0), anim);\n    \n    fragColor = vec4(col);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 497 */   public static String Smiley = "/*\n * Original shader from: https://www.shadertoy.com/view/MsdBDn\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nconst vec3 YELLOW = vec3(.9921, .898, .4823);\nconst vec3 RED = vec3(.5294, .1294, .2862);\nconst vec3 PINK = vec3(.9764, .7568, .8705);\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\nconst vec3 DARK_YELLOW_1 = vec3(.949, .8627, .2313);\nconst vec3 DARK_YELLOW_2 = vec3(.945, .9058, .6627);\nconst vec3 LIGHT_YELLOW_1 = vec3(.9921, .9843, .5019);\nconst vec3 LIGHT_YELLOW_2 = vec3(.9372, .9294, .8313);\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat circle(vec2 uv, vec2 center, float r, float sm)\n{\n    return 1. - smoothstep(r - sm, r, distance(uv, center));\n}\n\nfloat rectangle(vec2 uv, vec2 center, vec2 size, float sm)\n{\n    vec2 lb = center - size * .5;\n    vec2 rt = center + size * .5;\n    vec2 lbRes = smoothstep(lb, lb + sm, uv);\n    vec2 rtRes = 1. - smoothstep(rt - sm, rt, uv);\n    return lbRes.x * lbRes.y * rtRes.x * rtRes.y;\n}\n\n//sidesToCut -> radius percentage [l, b, r, t]\nfloat circleCut(vec2 uv, vec2 center, float r, vec4 sidesToCut, float sm)\n{\n    float c = circle(uv, center, r, sm);\n    \n    vec2 posToCut = center - (1. - sidesToCut.xy) * r;\n    vec2 lb = smoothstep(posToCut, posToCut + sm, uv);\n    posToCut = center + (1. - sidesToCut.zw) * r;\n    vec2 rt = 1. - smoothstep(posToCut - sm, posToCut, uv);    \n    return c * lb.x * lb.y * rt.x * rt.y;\n}\n\n//range and target -> [minX, minY, maxX, maxY]\nvec2 map(vec2 v, vec4 range, vec4 target)\n{\n    return ((v - range.xy) / (range.zw - range.xy)) * (target.zw - target.xy) + target.xy;\n}\n\nvec2 map01(vec2 v, vec4 range) \n{\n\treturn map(v, range, vec4(.0, .0, 1., 1.));\n}\n\nvec4 head(vec2 uv)\n{\n    float outline = circle(uv, vec2(.0), .45, .005);\n    float inside = circle(uv, vec2(.0), .425, .005);\n    float shadow = circle(uv, vec2(.015, -.015), .49, .12);\n    \n    vec3 col = YELLOW * inside;\n\treturn vec4(col, saturate(outline + shadow));\n}\n\nvec4 eye(vec2 uv, float speed)\n{\n    uv -= .5;\n    vec2 m = mouse;\n\t\n    float outline = circleCut(uv, vec2(0.), .5, vec4(0., .65, 0., 0.), .012);\n    float inside = circleCut(uv, vec2(0.), .424, vec4(0., .73, 0., 0.), .012);\n  float pupil = circle(uv, vec2(sin(speed*2.0)*0.3 , 0.15+0.15*cos(speed*4.0)), .15, .012);\n\t\n    //float pupil = circle(uv, vec2(m.x*0.5-0.25,m.y*0.3-0.01  ), .15, .012);\t\n    \n\tvec3 col = vec3(inside - pupil);\n    return vec4(col, outline);\n}\n\nvec4 mouth(vec2 uv)\n{\n    uv -= .5;\n    uv.x += .15 * uv.y ;\n    \n    float outline = circleCut(uv, vec2(0.), .5, vec4(0., .0, (sin(time) >= -0.5 ? 0.0 : 10.0), 1.15), .005);\n    float inside = circleCut(uv, vec2(0.), .465, vec4(0., .0, 0., 1.21), .005);\n    float upperLip = rectangle(uv, vec2(-.009, -.08), vec2(1.02, .033), .005);\n    float tongue = circle(uv, vec2(.12 , -.5), .23, .005);\n        \n    vec3 col = RED * inside;\n    col = mix(col, PINK, tongue * inside);\n    return vec4(col, saturate(outline + upperLip));\n}\n\nvec3 background(vec2 uv)\n{\n    float angle = atan(uv.y, uv.x);\n    float dist = length(uv) * 2.;\n    \n    vec3 c1 = mix(DARK_YELLOW_2, DARK_YELLOW_1, dist);\n    vec3 c2 = mix(LIGHT_YELLOW_2, LIGHT_YELLOW_1, dist);\n    \n    float v = cos(iTime + angle * 8.0) * .5 + .5;\n    return mix(c1, c2, smoothstep(0.48, 0.52, v));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    const float ratio = 16./9.;\n    \n    //uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 h = head(uv);\n    vec4 le = eye(map01(uv, vec4(-.207 * ratio, -.08, -.07 * ratio, .25)), time);\n    vec4 re = eye(map01(uv, vec4(.0, -.08, .155 * ratio, .25)), time*3.0);\n    vec4 m = mouth(map01(uv, vec4(-.19 * ratio, -.37, .165 * ratio, .35)));\n    \n    vec3 col = background(uv);\n    col.rgb = mix(col, h.rgb, h.a);\n    col.rgb = mix(col, le.rgb, le.a);\n    col.rgb = mix(col, re.rgb, re.a);\n\tcol.rgb = mix(col, m.rgb, m.a);\n    \n    fragColor = vec4(col, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 561 */   public static String Balls = "/*\n * Original shader from: https://www.shadertoy.com/view/3lKSWc\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nfloat map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n\treturn length(q) - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\n    {\n        vec3 p= o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 normalUV = uv;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 2.0));\n    \n    float the = iTime * 0.25;\n    mat2 rotate = mat2(cos(the), -sin(the), sin(the), cos(the));\n    r.zx *= rotate;\n    r.xy *= rotate;\n    \n    vec3 o = vec3(0.0, iTime, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n   \tvec3 fc = vec3(pow(fog, 1.25), pow(fog, 1.5), pow(fog, 0.75));\n    fc *= vec3(uv.x+2.0, uv.y+2.0, uv.x+uv.y);\n    fc /= (1.0 + distance(normalUV.x, 0.5));\n    fc /= (1.0 + distance(normalUV.y, 0.5));\n    fragColor = vec4(fc, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 582 */   public static String Rainy = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat rand(vec2 p){\n\tp+=.2127+p.x+.3713*p.y;\n\tvec2 r=4.789*sin(789.123*(p));\n\treturn fract(r.x*r.y);\n}\n\nfloat sn(vec2 p){\n\tvec2 i=floor(p-.5);\n\tvec2 f=fract(p-.5);\n\tf = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tfloat rt=mix(rand(i),rand(i+vec2(1.,0.)),f.x);\n\tfloat rb=mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.,1.)),f.x);\n\treturn mix(rt,rb,f.y);\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.y;\n\t\n\tfloat time = uv.x*999.+cos(time*5.5+uv.y*12.);\n\n\tvec2 p=uv.xy*vec2(3.,4.3);\n\tfloat f =\n\t.5*sn(p)\n\t+.25*sn(2.*p)\n\t+.125*sn(4.*p)\n\t+.0625*sn(8.*p)\n\t+.03125*sn(16.*p)+\n\t.015*sn(32.*p)\n\t;\n\n\tfloat newT = time*0.4 + sn(vec2(time*1.))*0.1;\n\tp.x-=time*0.2;\n\n\tp.y*=1.3;\n\tfloat f2=\n\t.5*sn(p)\n\t+.25*sn(2.04*p+newT*1.1)\n\t-.125*sn(4.03*p-time*0.3)\n\t+.0625*sn(8.02*p-time*0.4)\n\t+.03125*sn(16.01*p+time*0.5)+\n\t.018*sn(24.02*p);\n\n\tfloat f3=\n\t.5*sn(p)\n\t+.25*sn(2.04*p+newT*1.1)\n\t-.125*sn(4.03*p-time*0.3)\n\t+.0625*sn(8.02*p-time*0.5)\n\t+.03125*sn(16.01*p+time*0.6)+\n\t.019*sn(18.02*p);\n\n\tfloat f4 = f2*smoothstep(0.0,1.,uv.y);\n\n\tvec3 clouds = mix(vec3(-0.4,-0.3,-0.15),vec3(1.4,1.4,1.3),f4*f);\n\tfloat lightning = sn((f3)+vec2(pow(sn(vec2(time*4.5)),6.)));\n\n\tlightning *= smoothstep(0.0,1.,uv.y+0.5);\n\n\tlightning = smoothstep(0.76,1.,lightning);\n\tlightning=lightning*2.;\n\n\n\n\tclouds*=0.8;\n\tclouds += lightning +0.2;\n\n\n\tvec2 newUV = uv;\n\tnewUV.x-=time*0.3;\n\tnewUV.y+=time*3.;\n\tfloat strength = sin(time*0.5+sn(newUV))*0.1+0.15;\n\n\n\tvec3 painting = (clouds)+clamp((strength-0.1),0.,1.);\n\n\tfloat r=1.-length(max(abs(gl_FragCoord.xy / resolution.xy*2.-1.)-.5,0.));\n\tpainting*=r;\n\n\tgl_FragColor = vec4(painting, 1.);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 608 */   public static String ThunderClouds = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat rand(vec2 p){\n\tp+=.2127+p.x+.3713*p.y;\n\tvec2 r=4.789*sin(789.123*(p));\n\treturn fract(r.x*r.y);\n}\n\nfloat sn(vec2 p){\n\tvec2 i=floor(p-.5);\n\tvec2 f=fract(p-.5);\n\tf = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tfloat rt=mix(rand(i),rand(i+vec2(1.,0.)),f.x);\n\tfloat rb=mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.,1.)),f.x);\n\treturn mix(rt,rb,f.y);\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.y;\n\n\tvec2 p=uv.xy*vec2(3.,4.3);\n\tfloat f =\n\t.5*sn(p)\n\t+.25*sn(2.*p)\n\t+.125*sn(4.*p)\n\t+.0625*sn(8.*p)\n\t+.03125*sn(16.*p)+\n\t.015*sn(32.*p)\n\t;\n\n\tfloat newT = time*0.4 + sn(vec2(time*1.))*0.1;\n\tp.x-=time*0.2;\n\n\tp.y*=1.3;\n\tfloat f2=\n\t.5*sn(p)\n\t+.25*sn(2.04*p+newT*1.1)\n\t-.125*sn(4.03*p-time*0.3)\n\t+.0625*sn(8.02*p-time*0.4)\n\t+.03125*sn(16.01*p+time*0.5)+\n\t.018*sn(24.02*p);\n\n\tfloat f3=\n\t.5*sn(p)\n\t+.25*sn(2.04*p+newT*1.1)\n\t-.125*sn(4.03*p-time*0.3)\n\t+.0625*sn(8.02*p-time*0.5)\n\t+.03125*sn(16.01*p+time*0.6)+\n\t.019*sn(18.02*p);\n\n\tfloat f4 = f2*smoothstep(0.0,1.,uv.y);\n\n\tvec3 clouds = mix(vec3(-0.4,-0.3,-0.15),vec3(1.4,1.4,1.3),f4*f);\n\tfloat lightning = sn((f3)+vec2(pow(sn(vec2(time*4.5)),6.)));\n\n\tlightning *= smoothstep(0.0,1.,uv.y+0.5);\n\n\tlightning = smoothstep(0.76,1.,lightning);\n\tlightning=lightning*2.;\n\n\n\n\tclouds*=0.8;\n\tclouds += lightning +0.2;\n\n\n\tvec2 newUV = uv;\n\tnewUV.x-=time*0.3;\n\tnewUV.y+=time*3.;\n\tfloat strength = sin(time*0.5+sn(newUV))*0.1+0.15;\n\n\n\tvec3 painting = (clouds)+clamp((strength-0.1),0.,1.);\n\n\tfloat r=1.-length(max(abs(gl_FragCoord.xy / resolution.xy*2.-1.)-.5,0.));\n\tpainting*=r;\n\n\tgl_FragColor = vec4(painting, 1.);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 633 */   public static String Crosshair = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Start simplex noise\n\n\t//\n\t// Description : Array and textureless GLSL 2D/3D/4D simplex\n\t// noise functions.\n\t// Author : Ian McEwan, Ashima Arts.\n\t// Maintainer : ijm\n\t// Lastmod : 20110822 (ijm)\n\t// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t// Distributed under the MIT License. See LICENSE file.\n\t// https://github.com/ashima/webgl-noise\n\t//\n\t// Modified by Kabuto to return the derivative as well\n\t//\n\t\n\t\n\tvec4 permute(vec4 x) {\n\t     return mod(((x*34.0)+1.0)*x, 289.0);\n\t}\n\t\n\tvec4 taylorInvSqrt(vec4 r)\n\t{\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\t\n\t// modified perlin noise, giving value in w and derivative in xyz\n\tvec4 snoise(vec3 v)\n\t  {\n\t  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\n\t// First corner\n\t  vec3 i = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 = v - i + dot(i, C.xxx) ;\n\t\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\t\n\t  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  // x1 = x0 - i1 + 1.0 * C.xxx;\n\t  // x2 = x0 - i2 + 2.0 * C.xxx;\n\t  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\t\n\t// Permutations\n\t  i = mod(i,289.0);\n\t  vec4 p = permute( permute( permute(\n\t\t     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3 ns = n_ * D.wyz - D.xzx;\n\t\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\t\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\t\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\t\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\t\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\t\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\t\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\t\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t  float w = 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\t\t  \n\t// derivatives\n\t  vec3 dx = vec3(0.001, 0, 0);\n\t  vec4 mx = max(0.6 - vec4(dot(x0+dx,x0+dx), dot(x1+dx,x1+dx), dot(x2+dx,x2+dx), dot(x3+dx,x3+dx)), 0.0);\n\t  mx = mx * mx;\n\t  float wx = 42.0 * dot( mx*mx, vec4( dot(p0,x0+dx), dot(p1,x1+dx), dot(p2,x2+dx), dot(p3,x3+dx) ) );\n\n\t  vec3 dy = vec3(0, 0.001, 0);\n\t  vec4 my = max(0.6 - vec4(dot(x0+dy,x0+dy), dot(x1+dy,x1+dy), dot(x2+dy,x2+dy), dot(x3+dy,x3+dy)), 0.0);\n\t  my = my * my;\n\t  float wy = 42.0 * dot( my*my, vec4( dot(p0,x0+dy), dot(p1,x1+dy), dot(p2,x2+dy), dot(p3,x3+dy) ) );\n\n\t  vec3 dz = vec3(0, 0, 0.001);\n\t  vec4 mz = max(0.6 - vec4(dot(x0+dz,x0+dz), dot(x1+dz,x1+dz), dot(x2+dz,x2+dz), dot(x3+dz,x3+dz)), 0.0);\n\t  mz = mz * mz;\n\t  float wz = 42.0 * dot( mz*mz, vec4( dot(p0,x0+dz), dot(p1,x1+dz), dot(p2,x2+dz), dot(p3,x3+dz) ) );\n\t\t  \n\t  return vec4((wx-w)*100.0, (wy-w)*100.0, (wz-w)*100.0, w);\n\t}\n\n// End simplex noise\n\nfloat PI = 3.141592653589793;\n// vec2 center = vec2(0.5, 0.5);\n\nfloat atan2(vec2 v)\n{\n    return v.x == 0.0 ? sign(v.y)*PI/2.0 : atan(v.y, v.x);\n}\n\nfloat func(float theta, float nMin, float nMax, float d, float dMin, float dMax, float t) {\n\tfloat n = snoise(vec3(theta, 0, time * t)).w;\n\tif (nMin < n && n < nMax && dMin < d && d < dMax) {\n\t\treturn 0.7;\n\t} else {\n\t\treturn 0.;\n\t}\n}\n\nfloat mainImage(vec2 position, vec2 center) {\n\tfloat theta = atan2(position - center);\n\t\n\tfloat d = length(position - center);\n\t\n\tfloat result = 0.;\n\tresult += func(theta * 1.0 + time * 0.5, 0., 0.6, d, 0.14, 0.21, 0.2);\n\tresult += func(theta * 5.0 + 10. + time * -1., 0.3, 0.5, d, 0.17, 0.18, 0.1);\n\t// result += func(theta * 3.0 + 19. + time * 2., 0.4, 0.9, d, 0.16, 0.19, 1.2);\n\t\n\t// result += func(theta * 2.0 + 10. + time * -.5, 0.1, 1., d, 0.08, 0.104, 0.1);\n\n\tresult += func(theta * 2.0 + 10. + time * -.5, 0.1, 1., d, 0.38, .4, 0.1);\n\t\n\treturn result;\n}\n\nvoid main( void ) {\n\n\tvec2 m = (mouse - 0.5) * 0.1;\n\t\n\tvec2 position = ( gl_FragCoord.xy / resolution.x ) + m;\n\tposition.y += 0.2;\n\t\n\tvec4 o = vec4(0.3,0.3,0.3,1.);\n\t\n\tvec2 center = vec2(0.5, 0.5);\n\t\n\to.r = mainImage(position, center);\n\t\n\tposition += m;\n\to.g = o.b = mainImage(position, center);\n\t\n\tgl_FragColor = o;\n\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 707 */   public static String Schall = "/*\n * Original shader from: https://www.shadertoy.com/view/wsKXRK\n */\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.5);\n\n// --------[ Original ShaderToy begins here ]---------- //\n// V-Drop - Del 19/11/2019 - (Tunnel mix - Enjoy)\n// vertical version: https://www.shadertoy.com/view/tdGXWm\n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(905.0,25.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p)+0.1;\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    if (iMouse.z>0.5)\n    \tp.y *= 0.5;\n    float t =  iTime*0.4;\n    vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);\t// red\n    col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);\t// blue\n    col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);\t// green\n\tfragColor = vec4(col*(d*d), 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 732 */   public static String LSD = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//https://www.shadertoy.com/view/XsVSzW\n\nvoid main( void )\n{\n\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy )*6.0;\n\n\tvec2 uv0=uv;\n\tfloat i0=1.5;\n\tfloat i1=0.95;\n\tfloat i2=1.5;\n\tvec2 i4=vec2(0.0,0.0);\n\t\n\tfor(int s=0;s<10;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;\n\t\tr+=vec2(-r.y,r.x)*0.2;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.45;\n\t\ti2*=1.9;\n\t\ti4+=r.xy*1.0+0.5*time*i1;\n\t}\n\tfloat r=sin(uv.x-time)*0.2+0.1;\n\tfloat b=sin(uv.y+time)*0.2+0.5;\n\tfloat g=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.8+0.1;\n\tvec3 c=vec3(r,g,b);\n\tgl_FragColor = vec4(c,1.0);\n}";
/*     */   
/*     */   public static void draw() {}
/*     */ }


/* Location:              C:\Users\emlin\Desktop\BetterCraft.jar!\me\nzxter\bettercraft\mods\shader\BackgroundShader2.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */